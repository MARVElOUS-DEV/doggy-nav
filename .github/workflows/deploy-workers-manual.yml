name: Deploy Workers (Manual)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        type: choice
        required: true
        options:
          - production
          - staging
          - preview
        default: production
      cf_vars:
        description: 'Optional newline-separated KEY=VALUE pairs to pass as Worker vars (":" allowed in values)'
        required: false
        type: string
      db_name:
        description: 'Override D1 DB name (optional)'
        required: false
        type: string
      db_id:
        description: 'Override D1 DB id (optional)'
        required: false
        type: string

jobs:
  deploy:
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v3
        with:
          version: 9

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install deps
        run: pnpm install --frozen-lockfile

      - name: Resolve D1 variables
        env:
          INPUT_DB_NAME: ${{ inputs.db_name }}
          INPUT_DB_ID: ${{ inputs.db_id }}
          CF_D1_DB_NAME: ${{ vars.CF_D1_DB_NAME }}
          CF_D1_DB_ID: ${{ vars.CF_D1_DB_ID }}
        run: |
          set -euo pipefail
          DB_NAME="${INPUT_DB_NAME:-$CF_D1_DB_NAME}"
          DB_ID="${INPUT_DB_ID:-$CF_D1_DB_ID}"
          if [ -z "${DB_NAME:-}" ]; then
            echo "D1 database name not provided. Use input 'db_name' or set CF_D1_DB_NAME in environment" >&2
            exit 1
          fi
          if [ -z "${DB_ID:-}" ]; then
            echo "D1 database id not provided. Use input 'db_id' or set CF_D1_DB_ID in environment" >&2
            exit 1
          fi
          echo "D1_DATABASE_NAME=$DB_NAME" >> "$GITHUB_ENV"
          echo "D1_DATABASE_ID=$DB_ID" >> "$GITHUB_ENV"

      - name: Inject D1 vars into wrangler.jsonc
        working-directory: packages/doggy-nav-workers
        run: |
          set -euo pipefail
          # Escape sed replacement specials
          RNAME=$(printf '%s' "$D1_DATABASE_NAME" | sed -e 's/[&\/]/\\&/g')
          RID=$(printf '%s' "$D1_DATABASE_ID" | sed -e 's/[&\/]/\\&/g')
          sed -i "s|\${D1_DATABASE_NAME}|$RNAME|g" wrangler.jsonc
          sed -i "s|\${D1_DATABASE_ID}|$RID|g" wrangler.jsonc
          echo 'Updated wrangler.jsonc D1 config:'
          grep -n "database_\(name\|id\)" wrangler.jsonc || true

      - name: Apply D1 migrations (remote)
        working-directory: packages/doggy-nav-workers
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
        run: |
          set -euo pipefail
          echo "Applying migrations to D1 database ($D1_DATABASE_NAME) on account: $CLOUDFLARE_ACCOUNT_ID"
          pnpm exec wrangler d1 migrations apply "$D1_DATABASE_NAME" --remote

      - name: Deploy worker (with vars)
        working-directory: packages/doggy-nav-workers
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_VARS_INPUT: ${{ inputs.cf_vars }}
          # Non-secret toggles from environment vars
          ALLOWED_ORIGINS: ${{ vars.ALLOWED_ORIGINS }}
          RATE_LIMIT_MAX: ${{ vars.RATE_LIMIT_MAX }}
          RATE_LIMIT_WINDOW_MS: ${{ vars.RATE_LIMIT_WINDOW_MS }}
          NODE_ENV: ${{ vars.NODE_ENV }}
          PUBLIC_BASE_URL: ${{ vars.PUBLIC_BASE_URL }}
          REQUIRE_INVITE_CODE: ${{ vars.REQUIRE_INVITE_CODE }}
          # GitHub OAuth (non-secret)
          GITHUB_CLIENT_ID: ${{ vars.GITHUB_CLIENT_ID }}
          GITHUB_CALLBACK_URL: ${{ vars.GITHUB_CALLBACK_URL }}
          # Google OAuth
          GOOGLE_CLIENT_ID: ${{ vars.GOOGLE_CLIENT_ID }}
          GOOGLE_CALLBACK_URL: ${{ vars.GOOGLE_CALLBACK_URL }}
          # LinuxDo OAuth
          LINUXDO_CLIENT_ID: ${{ vars.LINUXDO_CLIENT_ID }}
          LINUXDO_CALLBACK_URL: ${{ vars.LINUXDO_CALLBACK_URL }}
          LINUXDO_AUTHORIZATION_URL: ${{ vars.LINUXDO_AUTHORIZATION_URL }}
          LINUXDO_TOKEN_URL: ${{ vars.LINUXDO_TOKEN_URL }}
          LINUXDO_PROFILE_URL: ${{ vars.LINUXDO_PROFILE_URL }}
          LINUXDO_SCOPE: ${{ vars.LINUXDO_SCOPE }}
          REQUIRE_CLIENT_SECRET: ${{ vars.REQUIRE_CLIENT_SECRET }}
          CLIENT_SECRET_BYPASS: ${{ vars.CLIENT_SECRET_BYPASS }}
          SERVER_COMMIT_ID: ${{ github.sha }}
        run: |
          set -euo pipefail
          add_var() { local k="$1"; local v="${2:-}"; if [ -n "$v" ]; then VARS+=(--var "$k:$v"); fi }
          declare -a VARS=()
          add_var ALLOWED_ORIGINS "${ALLOWED_ORIGINS:-}"
          add_var RATE_LIMIT_MAX "${RATE_LIMIT_MAX:-}"
          add_var RATE_LIMIT_WINDOW_MS "${RATE_LIMIT_WINDOW_MS:-}"
          add_var NODE_ENV "${NODE_ENV:-}"
          add_var PUBLIC_BASE_URL "${PUBLIC_BASE_URL:-}"
          add_var REQUIRE_INVITE_CODE "${REQUIRE_INVITE_CODE:-}"
          add_var GITHUB_CLIENT_ID "${GITHUB_CLIENT_ID:-}"
          add_var GITHUB_CALLBACK_URL "${GITHUB_CALLBACK_URL:-}"
          add_var GOOGLE_CLIENT_ID "${GOOGLE_CLIENT_ID:-}"
          add_var GOOGLE_CALLBACK_URL "${GOOGLE_CALLBACK_URL:-}"
          add_var LINUXDO_CLIENT_ID "${LINUXDO_CLIENT_ID:-}"
          add_var LINUXDO_CALLBACK_URL "${LINUXDO_CALLBACK_URL:-}"
          add_var LINUXDO_AUTHORIZATION_URL "${LINUXDO_AUTHORIZATION_URL:-}"
          add_var LINUXDO_TOKEN_URL "${LINUXDO_TOKEN_URL:-}"
          add_var LINUXDO_PROFILE_URL "${LINUXDO_PROFILE_URL:-}"
          add_var LINUXDO_SCOPE "${LINUXDO_SCOPE:-}"
          add_var REQUIRE_CLIENT_SECRET "${REQUIRE_CLIENT_SECRET:-false}"
          add_var CLIENT_SECRET_BYPASS "${CLIENT_SECRET_BYPASS:-/api/auth/register,/api/auth/login,/api/application/verify-client-secret,/api/auth/:provider,/api/auth/:provider/callback,/api/auth/providers,/api/auth/config,/api/auth/me,/api/auth/logout}"
          add_var SERVER_COMMIT_ID "${SERVER_COMMIT_ID:-}"
          # Optional manual K=V input; split only on first '=' to keep ':' in values
          if [ -n "${CF_VARS_INPUT:-}" ]; then
            printf '%s\n' "$CF_VARS_INPUT" | tr -d '\r' | while IFS= read -r line || [ -n "$line" ]; do
              [ -z "$line" ] && continue
              case "$line" in \#*) continue ;; esac
              case "$line" in *=*) ;; *) continue ;; esac
              key="${line%%=*}"
              value="${line#*=}"
              [ -z "$key" ] && continue
              add_var "$key" "$value"
            done
          fi

          if [ ${#VARS[@]} -eq 0 ]; then
            echo "No vars provided; deploying without --var flags."
            pnpm exec wrangler deploy
          else
            echo "Deploying with vars (merging when supported)..."
            KEEP_FLAG=""
            if pnpm exec wrangler deploy --help | grep -q -- "--keep-vars"; then
              KEEP_FLAG="--keep-vars"
            fi
            pnpm exec wrangler deploy ${KEEP_FLAG} "${VARS[@]}"
          fi
